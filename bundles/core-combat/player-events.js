'use strict';

const util = require('util');

/**
 * Auto combat module
 */
module.exports = (srcPath) => {
  const Broadcast = require(srcPath + 'Broadcast');
  const LevelUtil = require(srcPath + 'LevelUtil');

  return  {
    listeners: {
      updateTick: state => function () {
        // Check to see if the player has died since the last combat tick. If
        // we only did the check right when the player was damaged then you
        // could potentially wind up in a situation where the player performed
        // a mid-round attack that killed the target, then the next round the
        // target kills the player. So let's not let that happen.
        if (this.getAttribute('health') <= 0) {
          this.combatants.forEach(combatant => {
            this.removeCombatant(combatant);
            combatant.removeCombatant(this);
            if (!combatant.isInCombat()) {
              combatant.setAttributeToMax('health');
            }
          }, this);

          const target = this.combatData.killedBy;
          if (target) {
            Broadcast.sayAt(this, `<bold><red>${target.name} killed you!</red></bold>`);
            target.emit('deathblow', this);
            this.emit('killed', target);
          }
          return;
        }

        if (!this.isInCombat()) {
          return;
        }

        // TODO: For now player/enemy speed is a fixed 2.5 seconds, base it off weapon speed later
        const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const playerSpeed = 1.5;
        const targetSpeed = 2;
        const playerDamage = rand(5, 20);
        const targetDamage = rand(5, 20);

        let hadActions = false;
        for (const target of this.combatants) {
          // player actions
          if (target.getAttribute('health') <= 0) {
            this.removeCombatant(target);
            target.removeCombatant(this);

            Broadcast.sayAt(this, `<bold>${target.name} is <red>Dead</red>!</bold>`);
            target.emit('killed', this);
            this.emit('deathblow', target);

            // TODO: For now respawn happens here, this is shitty
            const newNpc = state.MobFactory.clone(target);
            newNpc.hydrate(state);
            if (newNpc.room) {
              newNpc.room.removeNpc(newNpc);
            }
            target.room.addNpc(newNpc);
            target.emit('spawn');
            target.area.removeNpc(target);
            continue;
          }

          if (this.combatData.lag <= 0) {
            hadActions = true;
            const damage = Math.min(playerDamage, target.getAttribute('health'));

            target.emit('hit', this, damage);
            const startingHealth = target.getAttribute('health');
            target.lowerAttribute('health', damage);
            Broadcast.sayAt(this, `You strike <bold>${target.name}</bold> for <bold>${damage}</bold> damage`);

            this.combatData.lag = playerSpeed * 1000;
          } else {
            const elapsed = Date.now() - this.combatData.roundStarted;
            this.combatData.lag -= elapsed;
          }
          this.combatData.roundStarted = Date.now();

          // target actions
          if (target.combatData.lag <= 0) {
            hadActions = true;
            const damage = Math.min(targetDamage, this.getAttribute('health'));

            this.emit('hit', target, damage);
            
            const startingHealth = this.getAttribute('health');
            this.lowerAttribute('health', damage);

            Broadcast.sayAt(this, `<bold>${target.name}</bold> hit you for <bold><red>${damage}</red></bold> damage`);

            if (this.getAttribute('health') <= 0) {
              this.combatData.killedBy = target;
              break;
            }

            target.combatData.lag = targetSpeed * 1000;
          } else {
            const elapsed = Date.now() - target.combatData.roundStarted;
            target.combatData.lag -= elapsed;
          }
          target.combatData.roundStarted = Date.now();
        }

        if (!this.isInCombat()) {
          // reset combat data to remove any lag
          this.combatData = {};

          // TODO: There is no regen at the moment so if they won just reset their health
          this.setAttributeToMax('health');
        }

        if (hadActions) {
          Broadcast.sayAt(this, '');
          Broadcast.prompt(this);
          const percWidth = 50;

          if (!this.isInCombat()) {
            return;
          }

          // render health bars
          let currentPerc = Math.floor((this.getAttribute('health') / this.getMaxAttribute('health')) * 100);
          let buf = '<bold>You</bold>: <green>[<bold>';
          buf += new Array(Math.ceil((currentPerc / 100) * percWidth)).join('#') + '|';
          buf += new Array(percWidth - Math.ceil((currentPerc  / 100) * percWidth)).join(' ');
          buf += '</bold>]</green>';
          buf += ` <bold>${this.getAttribute('health')}/${this.getMaxAttribute('health')}</bold>`;
          Broadcast.sayAt(this, buf);

          for (const target of this.combatants) {
            let currentPerc = Math.floor((target.getAttribute('health') / target.getMaxAttribute('health')) * 100);
            let buf = `<bold>${target.name}</bold>: `;
            buf += '<red>[<bold>';
            buf += new Array(Math.ceil((currentPerc / 100) * percWidth)).join('#') + '|';
            buf += new Array(percWidth - Math.ceil((currentPerc  / 100) * percWidth)).join(' ');
            buf += '</bold>]</red>';
            buf += ` <bold>${target.getAttribute('health')}/${target.getMaxAttribute('health')}</bold>`;
            Broadcast.sayAt(this, buf);
          }

          Broadcast.sayAt(this, ''); // add a blank line after health prompts
        }
      },

      /**
       * Player was killed
       * @param {Character} target
       */
      killed: state => function (target) {
        // Restore health to full on death for now
        this.setAttributeToMax('health');
        Broadcast.sayAt(this, "Whoops, that sucked!");
        Broadcast.prompt(this);
      },

      /**
       * Player killed a target
       * @param {Character} target
       */
      deathblow: state => function (target) {
        this.emit('experience', LevelUtil.mobExp(target.level));
        this.setAttributeToMax('health');
        Broadcast.prompt(this);
      }
    }
  };
};
