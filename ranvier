#!/usr/bin/env node
'use strict';
/**
 * Main file, use this to run the server:
 * node ranvier [options]
 *
 * Options:
 *   -v Verbose loggin
 *   --port Port to listen on
 *   --locale Locale to act as the default
 *   --save Minutes between autosave
 *   --respawn Minutes between respawn
 */

//TODO: Refactor

  // built-ins
const net = require('net');
const util = require('util');
const commander = require('commander');
const wrap = require('wrap-ansi');
const pkg = require('./package.json');

  // local
const Telnet = require('./src/Telnet');
const Config = require('./src/Config');
const AccountManager = require('./src/AccountManager');
const AreaManager = require('./src/AreaManager');
const CommandManager = require('./src/CommandManager');
const ChannelManager = require('./src/ChannelManager');
const EventManager = require('./src/EventManager');
const BehaviorManager = require('./src/BehaviorManager');
const ItemManager = require('./src/ItemManager');
const ItemFactory = require('./src/ItemFactory');
const MobFactory = require('./src/MobFactory');
const PlayerManager = require('./src/PlayerManager');
const QuestFactory = require('./src/QuestFactory');
const RoomManager = require('./src/RoomManager');
const HelpManager = require('./src/HelpManager');
//const EffectManager = require('./src/PlayerManager');

  // third party
const argv      = require('optimist').argv;
const longjohn  = require('longjohn');
const pe        = require('pretty-error').start();

pe.skipNodeFiles();

/**
 * These aren't really globals; they're only "global" to this file,
 * we'll pass them around via construction as needed
 */

// storage of main game entities

let server;

// cmdline options
commander
  .version(pkg.version)
  .option('-s, --save [time]', 'Number of seconds between auto-save ticks [10]', 10)
  .option('-r, --respawn [time]', 'Number of minutes between respawn ticks [120]', 120)
  .option('-p, --port [portNumber]', 'Port to host telnet server [23]', Config.get('port', 23))
  .option('-v, --verbose', 'Verbose console logging.', true)
  .parse(process.argv);

// Set debug variable
process.env['NODE_DEBUG'] = 'net';

// global state
let GameState = {};
let saveInterval, tickInterval;

/**
 * Do the dirty work
 */
function init(restartServer) {
  util.log("START - Loading entities");
  restartServer = typeof restartServer === 'undefined' ? true : restartServer;

  GameState = {
    // Stores all logged in accounts
    AccountManager: new AccountManager(),
    // Stores all loaded areas
    AreaManager: new AreaManager(),
    // Stores all loaded commands
    CommandManager: new CommandManager(),
    // Stores all loaded channels
    ChannelManager: new ChannelManager(),
    // Stores all loaded spells, just kidding, it stores input (socket) events
    InputEventManager: new EventManager(),
    // Helper for creating/cloning items
    ItemFactory: new ItemFactory(),
    // Stores all loaded items
    ItemManager: new ItemManager(),
    // Helper for creating/cloning Npcs (mobs)
    MobFactory: new MobFactory(),
    // Store behavior events for various entities
    MobBehaviorManager: new BehaviorManager(),
    ItemBehaviorManager: new BehaviorManager(),
    RoomBehaviorManager: new BehaviorManager(),
    // Stores all connected players
    PlayerManager: new PlayerManager(),
    QuestFactory: new QuestFactory(),
    // Stores all loaded rooms across all areas ever
    RoomManager: new RoomManager(),
    // Stores all loaded helpfiles
    HelpManager: new HelpManager(),

    // All global server settings like default respawn time, save interval, port, what bundles to load, etc.
    Config,
  };

  // Setup bundlemanager
  const BundleManager = new (require('./src/BundleManager'))(GameState);

  BundleManager.loadBundles();

  // Set up web API
  const WebInterface = new (require('./src/WebInterface'))(GameState);

  WebInterface.init();

  if (restartServer) {
    util.log("START - Starting server");

    /**
    * Effectively the 'main' game loop but not really because it's a REPL
    */
    server = new Telnet.TelnetServer({}, socket => {
      socket.on('interrupt', () => {
        socket.write("\n*interrupt*\n");
      });

      socket.on('error', err => util.log(err));

      // Register all of the events
      GameState.InputEventManager.attach(socket);

      socket.write("Connecting...\n");
      util.log("User connected...");

      // @see: bundles/core-events/events/login.js
      socket.emit('intro', socket);
    }).netServer;

    // start the server
    server.listen(commander.port).on('error', err => {
      if (err.code === 'EADDRINUSE') {
        util.log("Cannot start server on port " + commander.port + ", address is already in use.");
        util.log("Do you have a MUD server already running?");
      } else if (err.code === 'EACCES') {
        util.log("Cannot start server on port " + commander.port + ": permission denied.");
        util.log("Are you trying to start it on a priviledged port without being root?");
      } else {
        util.log("Failed to start MUD server:");
        util.log(err);
      }
      process.exit(1);
    });

    // save every 10 minutes
    util.log("Setting autosave to " + commander.save + " seconds.");
    clearInterval(saveInterval);
    saveInterval = setInterval(save, commander.save * 1000);

    // Ticks for effect processing happen every second
    clearInterval(tickInterval);
    tickInterval = setInterval(() => {
      GameState.PlayerManager.emit('updateTick');
    }, 500);

    // TODO: RESPAWN
  }

  util.log(util.format("Server started on port: %d %s", commander.port, '...' ));
  server.emit('startup');
};


// START IT UP!
init();


/**
 * Save all connected players
 */
function save(callback) {
  GameState.PlayerManager.saveAll();
  if (callback) { callback(); }
}

// Not game stuff, this is for the server executable
const yaml = require('js-yaml');
const fs   = require('fs');
process.stdin.setEncoding('utf8');

/**
 * Commands that the server executable itself accepts
 */
const server_commands = {
  save,
};

process.stdin.resume();

process.stdin.on('data', data => {
  data = data.trim();
  const command = data.split(' ')[0];

  if (!(command in server_commands)) {
    console.log("That's not a real command...");
    return;
  }

  const args = data.split(' ').slice(1).join(' ');

  server_commands[command](args);
});
// vim: set syn=javascript :
